{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n# AI Vision Color Descriptions\nai_vision_11__RED = Colordesc(1, 226, 80, 116, 10, 0.2)\nai_vision_11__BLUE = Colordesc(2, 69, 202, 228, 10, 0.2)\n# AI Vision Code Descriptions\nai_vision_11 = AiVision(Ports.PORT11, ai_vision_11__RED, ai_vision_11__BLUE)\ndistance_13 = Distance(Ports.PORT13)\ndistance_12 = Distance(Ports.PORT12)\ninertial_1 = Inertial(Ports.PORT1)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n#region VEXcode Configuration\nfrom vex import *\nimport urandom\n\n# Brain and AI Vision Configuration\nbrain = Brain()\ncontroller = Controller()\n\n# AI Vision Color Descriptions\nai_vision_BLUE = Colordesc(1, 55, 136, 145, 10, 0.2)\nai_vision_RED = Colordesc(1, 226, 80, 116, 10, 0.2)\nai_vision = AiVision(Ports.PORT11, ai_vision_BLUE)\n\n# Motor Configuration\nleft_motor = Motor(Ports.PORT2, GearSetting.RATIO_18_1)\nright_motor = Motor(Ports.PORT10, GearSetting.RATIO_18_1)\nleft_motor2 = Motor(Ports.PORT4, GearSetting.RATIO_18_1)\nright_motor2 = Motor(Ports.PORT5, GearSetting.RATIO_18_1)\nclaw_motor_1 = Motor(Ports.PORT18)\nclaw_motor_2 = Motor(Ports.PORT19)\nmotor_a = Motor(Ports.PORT8)\nmotor_b = Motor(Ports.PORT9)\nmotor_c = Motor(Ports.PORT3, GearSetting.RATIO_18_1)\nlift_l = Motor(Ports.PORT7, GearSetting.RATIO_18_1)\nlift_r = Motor(Ports.PORT6, GearSetting.RATIO_18_1)\n\n# Robot Parameters\nwheel_circumference = 11  # inches per wheel rotation\nturn_time_90 = 1.5  # estimated time to turn 90 degrees\nturn_time_45 = 0.75  # estimated time to turn 45 degrees\nCENTER_MIN, CENTER_MAX = 150, 170  # Vision centering thresholds\n\nSTALL_THRESHOLD = 5  # Motor stall speed threshold\nSTALL_DELAY = 500  # Stall detection delay in ms\n\nstall_timer = 0\n\n# Movement Functions\ndef move_one_rotation(forward=True):\n    direction = FORWARD if forward else REVERSE\n    left_motor.spin_for(direction, 720, DEGREES, 100, PERCENT, wait=False)\n    right_motor.spin_for(REVERSE if forward else FORWARD, 720, DEGREES, 100, PERCENT, wait=True)\n    left_motor2.spin_for(direction, 720, DEGREES, 100, PERCENT, wait=False)\n    right_motor2.spin_for(REVERSE if forward else FORWARD, 720, DEGREES, 100, PERCENT, wait=True)\n\ndef turn_90(direction=LEFT):\n    \"\"\"Turn 90 degrees in the specified direction.\"\"\"\n    left_dir = REVERSE if direction == LEFT else FORWARD\n    right_dir = FORWARD if direction == LEFT else REVERSE\n    left_motor.spin(right_dir, 20, PERCENT)\n    left_motor2.spin(right_dir, 20, PERCENT)\n    right_motor.spin(right_dir, 20, PERCENT)\n    right_motor2.spin(right_dir, 20, PERCENT)\n\n    wait(turn_time_90, SECONDS)\n    left_motor.stop()\n    right_motor.stop()\n    left_motor2.stop()\n    right_motor2.stop()\n\ndef turn_45(direction):\n    \"\"\"Turn 45 degrees in the specified direction.\"\"\"\n    left_dir = FORWARD if direction == LEFT else REVERSE\n    right_dir = FORWARD if direction == LEFT else REVERSE\n    left_motor.spin(right_dir, 25, PERCENT)\n    left_motor2.spin(right_dir, 25, PERCENT)\n    right_motor.spin(right_dir, 25, PERCENT)\n    right_motor2.spin(right_dir, 25, PERCENT)\n    wait(turn_time_45, SECONDS)\n    left_motor.stop()\n    right_motor.stop()\n    left_motor2.stop()\n    right_motor2.stop()\n\ndef count_rings(color):\n    # Counting rings using rear AI vision camera\n    ring_num = ai_vision.take_snapshot(color)\n    brain.screen.print(ring_num)\n    if (ring_num >= 4):\n        open_claw()\n        move_one_rotation(FORWARD)\n\ndef search_for_color(color):\n    # Search for color using AI vision\n    vision_objects = ai_vision.take_snapshot(color)\n    \n    brain.screen.set_cursor(1, 1)\n    \n    if len(vision_objects) > 0:\n        obj = vision_objects[0]\n        brain.screen.print(\"YES THERE IS : \", color)\n        return obj.centerX\n    else: \n        brain.screen.print(\"NO \", color, \" FOUND!\")\n        return None\n\n# Claw Functions\ndef open_claw():\n    claw_motor_1.spin(REVERSE, 50, PERCENT)\n    claw_motor_2.spin(FORWARD, 50, PERCENT)\n    wait(0.5, SECONDS)\n    claw_motor_1.stop(HOLD)\n    claw_motor_2.stop(HOLD)\n\ndef close_claw():\n    claw_motor_1.spin(FORWARD, 80, PERCENT)\n    claw_motor_2.spin(REVERSE, 80, PERCENT)\n    wait(0.5, SECONDS)\n    claw_motor_1.stop(HOLD)\n    claw_motor_2.stop(HOLD)\n\ndef move_toward_color():\n    STALL_CURRENT_THRESHOLD = 2.0  # Current threshold for stall detection\n    STALL_VELOCITY_THRESHOLD = 10  # Velocity threshold for stall detection\n    STALL_REVERSE_DURATION = 0.5  # Time to reverse motor in seconds\n    STALL_REVERSE_SPEED = 50  # Speed to reverse motor in percent\n\n    while True:\n        # Continuously update object detection and distance\n        vision_objects = ai_vision.take_snapshot(ai_vision_BLUE)\n        distance_l = distance_13.object_distance(MM)\n        distance_r = distance_12.object_distance(MM)\n        \n        # Check distance for safety\n        if distance_l < 90 or distance_r < 90:\n            brain.screen.clear_screen()\n            brain.screen.print(\"Too close! Backing up.\")\n            \n            # Back up to maintain a safe distance\n            left_motor.spin(REVERSE, 50, PERCENT)\n            right_motor.spin(FORWARD, 50, PERCENT)\n            left_motor2.spin(REVERSE, 50, PERCENT)\n            right_motor2.spin(FORWARD, 50, PERCENT)\n            wait(1, SECONDS)  # Back up for 1 second\n            left_motor.stop()\n            right_motor.stop()\n            left_motor2.stop()\n            right_motor2.stop()\n            continue  # Skip the rest of the loop\n        \n        if len(vision_objects) > 0:\n            # Object detected, move toward it\n            obj = vision_objects[0]\n            center_x = obj.centerX\n            brain.screen.clear_screen()\n            brain.screen.print(\"Object detected at: \", center_x)\n            \n            # Move toward the object\n            left_motor.spin(FORWARD, 80, PERCENT)\n            right_motor.spin(REVERSE, 80, PERCENT)\n            left_motor2.spin(FORWARD, 80, PERCENT)\n            right_motor2.spin(REVERSE, 80, PERCENT)\n            motor_a.spin(FORWARD, 100, PERCENT)\n            motor_b.spin(REVERSE, 100, PERCENT)\n            motor_c.spin(FORWARD, 100, PERCENT)\n\n            # Check for stalls and reverse if needed\n            if stall(left_motor, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n                reverse_motor(left_motor, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n            if stall(right_motor, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n                reverse_motor(right_motor, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n            if stall(left_motor2, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n                reverse_motor(left_motor2, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n            if stall(right_motor2, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n                reverse_motor(right_motor2, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n            \n        else:\n            # No object detected, search by turning\n            brain.screen.clear_screen()\n            brain.screen.print(\"Searching...\")\n            \n            # Turn slowly to scan\n            left_motor.spin(REVERSE, 12, PERCENT)\n            left_motor2.spin(REVERSE, 12, PERCENT)\n            right_motor.spin(REVERSE, 12, PERCENT)\n            right_motor2.spin(REVERSE, 12, PERCENT)\n        \n        # Add a small delay for smooth operation\n        wait(150, MSEC)\n\n#def pre_autonomous():\n    #something something back it up here\n\n\n\n# Autonomous Routine\n\ndef autonomous():\n    open_claw()\n    right_motor.spin(FORWARD, 70, PERCENT)\n    left_motor.spin(REVERSE, 70, PERCENT)\n    left_motor2.spin(REVERSE, 70, PERCENT)\n    right_motor2.spin(FORWARD, 70, PERCENT)\n    wait(0.40, SECONDS)\n    turn_90(LEFT)\n    wait(0.08, SECONDS)\n    left_motor.spin(REVERSE, 65, PERCENT)\n    right_motor.spin(FORWARD, 65, PERCENT)\n    left_motor2.spin(REVERSE, 65, PERCENT)\n    right_motor2.spin(FORWARD, 65, PERCENT)\n    wait(0.45, SECONDS)\n    close_claw()\n    wait(0.30, SECONDS)\n    left_motor.spin(FORWARD, 80, PERCENT)\n    right_motor.spin(REVERSE, 80, PERCENT)\n    left_motor2.spin(FORWARD, 80, PERCENT)\n    right_motor2.spin(REVERSE, 80, PERCENT)\n    motor_a.spin(FORWARD, 100, PERCENT)\n    motor_b.spin(REVERSE, 100, PERCENT)\n    motor_c.spin(FORWARD, 100, PERCENT)\n    wait(2, SECONDS)\n    right_motor.spin(FORWARD, 70, PERCENT)\n    left_motor.spin(REVERSE, 70, PERCENT)\n    left_motor2.spin(REVERSE, 70, PERCENT)\n    right_motor2.spin(FORWARD, 70, PERCENT)\n    motor_a.spin(FORWARD, 100, PERCENT)\n    motor_b.spin(REVERSE, 100, PERCENT)\n    motor_c.spin(FORWARD, 100, PERCENT)\n    wait(2, SECONDS)\n    turn_45(LEFT)\n    motor_a.stop()\n    motor_b.stop()\n    motor_c.stop()\n\n    wait(0.5)\n\ndef stall(motor, current_threshold, velocity_threshold):\n    \"\"\"Check if a motor is stalled and return True if so.\"\"\"\n    current = abs(motor.current(CurrentUnits.AMP))\n    velocity = abs(motor.velocity(PERCENT))\n    is_stalled = current > current_threshold and velocity < velocity_threshold\n    if is_stalled:\n        brain.screen.clear_screen()\n        brain.screen.set_cursor(1, 1)\n        brain.screen.print(\"Stall detected on motor {motor.port}\")\n    return is_stalled\n\ndef reverse_motor(motor, duration=0.5, speed=50):\n    \"\"\"Reverse the motor briefly to recover from a stall.\"\"\"\n    motor.spin(REVERSE, speed, PERCENT)\n    wait(duration, SECONDS)\n    motor.stop()\n\n# Constants for stall detection\nSTALL_CURRENT_THRESHOLD = 2.0  # Example threshold in amps\nSTALL_VELOCITY_THRESHOLD = 10  # Example threshold in percent\nSTALL_REVERSE_DURATION = 0.5  # Time to reverse motor in seconds\nSTALL_REVERSE_SPEED = 50  # Speed to reverse motor in percent\n\n# Driver Control\ndef driver_control():   \n    autonomous()\n    while True:\n        \n        # Driving Control\n        left_motor.spin(FORWARD, controller.axis3.position(), PERCENT)\n        left_motor2.spin(FORWARD, controller.axis3.position(), PERCENT)\n        right_motor.spin(REVERSE, controller.axis2.position(), PERCENT)\n        right_motor2.spin(REVERSE, controller.axis2.position(), PERCENT)\n\n        # Check for stalls in driving motors\n        if stall(left_motor, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n            reverse_motor(left_motor, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n        if stall(right_motor, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n            reverse_motor(right_motor, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n        if stall(left_motor2, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n            reverse_motor(left_motor2, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n        if stall(right_motor2, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n            reverse_motor(right_motor2, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n\n        # Claw Control\n        if controller.buttonL1.pressing():\n            open_claw()\n        elif controller.buttonL2.pressing():\n            close_claw()\n\n        # Spin Control (R1 and R2)\n        if controller.buttonR1.pressing():\n            motor_a.spin(FORWARD, 100, PERCENT)\n            motor_b.spin(REVERSE, 100, PERCENT)\n            motor_c.spin(FORWARD, 100, PERCENT)\n\n            # Check for stalls and reverse if needed\n            if stall(motor_a, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n                reverse_motor(motor_a, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n            if stall(motor_b, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n                reverse_motor(motor_b, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n            if stall(motor_c, STALL_CURRENT_THRESHOLD, STALL_VELOCITY_THRESHOLD):\n                reverse_motor(motor_c, STALL_REVERSE_DURATION, STALL_REVERSE_SPEED)\n        elif controller.buttonR2.pressing():\n            motor_a.spin(REVERSE, 100, PERCENT)\n            motor_b.spin(FORWARD, 100, PERCENT)\n            motor_c.spin(REVERSE, 100, PERCENT)\n        else:\n            motor_a.stop()\n            motor_b.stop()\n            motor_c.stop()\n\n        # Lift Control\n        if controller.buttonA.pressing():\n            lift_l.spin(REVERSE, 90, PERCENT)\n            lift_r.spin(FORWARD, 90, PERCENT)\n        elif controller.buttonB.pressing():\n            lift_l.spin(FORWARD, 50, PERCENT)\n            lift_r.spin(REVERSE, 50, PERCENT)\n        else:\n            lift_l.stop(HOLD)\n            lift_r.stop(HOLD)\n\n        # Adjust claw motor power during driving\n        if controller.axis3.position() != 0 or controller.axis2.position() != 0:\n            claw_motor_1.set_max_torque(50, PERCENT)  # Reduce claw motor torque\n            claw_motor_2.set_max_torque(50, PERCENT)\n        else:\n            claw_motor_1.set_max_torque(100, PERCENT)  # Restore claw motor torque\n            claw_motor_2.set_max_torque(100, PERCENT)\n\n        wait(20, MSEC)\n\n\nwhile True:\n    driver_control()","textLanguage":"python","robotConfig":[{"port":[11],"name":"ai_vision_11","customName":false,"deviceType":"AIVision","deviceClass":"aivision","setting":{"config":"{\"colors\":[{\"id\":1,\"name\":\"RED\",\"nameValid\":\"Valid\",\"lastValidName\":\"RED\",\"red\":226.4106818181818,\"green\":80.10318181818182,\"blue\":116.435,\"hueRange\":10,\"saturationRange\":0.2},{\"id\":2,\"name\":\"BLUE\",\"nameValid\":\"Valid\",\"lastValidName\":\"BLUE\",\"red\":69.43997252747253,\"green\":202.37307692307692,\"blue\":227.82822802197802,\"hueRange\":10,\"saturationRange\":0.2}],\"codes\":[],\"tags\":false,\"AIObjects\":false,\"AIObjectModel\":[\"Ball(Blue)\",\"Ball(Green)\",\"Ball(Red)\",\"Ring(Blue)\",\"Ring(Green)\",\"Ring(Red)\",\"Cube(Blue)\",\"Cube(Green)\",\"Cube(Red)\"],\"AIModelMetadata\":{\"id\":0,\"version\":1,\"name\":\"Classroom Objects\"},\"aiModelDropDownValue\":\"Classroom Objects\"}","isConfigured":"false"},"triportSourcePort":22},{"port":[13],"name":"distance_13","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[12],"name":"distance_12","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[1],"name":"inertial_1","customName":false,"deviceType":"Inertial","deviceClass":"inertial","setting":{},"triportSourcePort":22}],"slot":6,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}