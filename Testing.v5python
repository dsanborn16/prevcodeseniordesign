{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\npotentiometerV2_a = PotentiometerV2(brain.three_wire_port.a)\npotentiometerV2_b = PotentiometerV2(brain.three_wire_port.b)\n# AI Vision Color Descriptions\nai_vision_11__RED = Colordesc(2, 208, 56, 93, 10, 0.2)\nai_vision_11__BLUE = Colordesc(1, 67, 156, 216, 10, 0.2)\n# AI Vision Code Descriptions\nai_vision_11 = AiVision(Ports.PORT11, ai_vision_11__RED, ai_vision_11__BLUE)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n# Import VEX libraries\nfrom vex import *\n\n# Initialize brain and controller\nbrain = Brain()\ncontroller = Controller()\n\n# Define motors with corresponding ports and gear ratios\nleft_motor = Motor(Ports.PORT2, GearSetting.RATIO_18_1)\nright_motor = Motor(Ports.PORT10, GearSetting.RATIO_18_1)\nclaw_motor_1 = Motor(Ports.PORT18)\nclaw_motor_2 = Motor(Ports.PORT19)\nmotor_a = Motor(Ports.PORT8)\nmotor_b = Motor(Ports.PORT9)\nmotor_c = Motor(Ports.PORT3, GearSetting.RATIO_18_1)\nlift_l = Motor(Ports.PORT7, GearSetting.RATIO_18_1)\nlift_r = Motor(Ports.PORT6, GearSetting.RATIO_18_1)\n\n\n# Robot specifications\nwheel_circumference = 11  # inches per wheel rotation\nturn_time_90 = 1.5  # estimated time to turn 90 degrees (seconds)\nturn_time_45 = 0.5  # estimated time to turn 45 degrees (seconds)\n\ndef move_one_rotation_f():\n    # Start motors a, b, and c spinning at full speed\n    motor_a.spin(FORWARD, 100, PERCENT)\n    motor_b.spin(REVERSE, 100, PERCENT)\n    motor_c.spin(FORWARD, 90, PERCENT)\n    \n    # Move the robot forward by one wheel rotation (11 inches) at 100% speed\n    left_motor.spin_for(FORWARD, 720, DEGREES, 100, PERCENT, wait=False)\n    right_motor.spin_for(REVERSE, 720, DEGREES, 100, PERCENT, wait=True)\n\ndef move_one_rotation_fh():\n    # Start motors a, b, and c spinning at full speed\n    motor_a.spin(FORWARD, 100, PERCENT)\n    motor_b.spin(REVERSE, 100, PERCENT)\n    motor_c.spin(FORWARD, 100, PERCENT)\n    \n    # Move the robot forward by one wheel rotation (11 inches) at 100% speed\n    left_motor.spin_for(FORWARD, 370, DEGREES, 100, PERCENT, wait=False)\n    right_motor.spin_for(REVERSE, 370, DEGREES, 100, PERCENT, wait=True)\ndef move_one_rotation_b():\n    # Move the robot backward by one wheel rotation (11 inches) at 100% speed\n    left_motor.spin_for(REVERSE, 740, DEGREES, 100, PERCENT, wait=False)\n    right_motor.spin_for(FORWARD, 740, DEGREES, 100, PERCENT, wait=True)\n\ndef move_one_rotation_bh():\n    # Start motors a, b, and c spinning at full speed\n    motor_a.spin(REVERSE, 60, PERCENT)\n    motor_b.spin(FORWARD, 60, PERCENT)\n    motor_c.spin(REVERSE, 60, PERCENT)\n    # Move the robot backward half the distance\n    left_motor.spin_for(REVERSE, 370, DEGREES, 100, PERCENT, wait=False)\n    right_motor.spin_for(FORWARD, 370, DEGREES, 100, PERCENT, wait=True)\n\ndef close_claw():\n    # Close the claw by spinning the claw motors\n    claw_motor_1.spin(FORWARD, 100, PERCENT)\n    claw_motor_2.spin(REVERSE, 100, PERCENT)\n    wait(0.5, SECONDS)  # Adjust the time to fully close the claw\n    claw_motor_1.stop(HOLD)\n   \n\ndef open_claw():\n    # Open the claw by spinning the claw motors\n    claw_motor_1.spin(REVERSE, 100, PERCENT)\n    claw_motor_2.spin(FORWARD, 100, PERCENT)\n    wait(0.5, SECONDS)  # Adjust the time to fully close the claw\n    claw_motor_1.stop(HOLD)\n    \n\ndef turn_90(direction=LEFT):\n    # Turn the robot 90 degrees\n    if direction == LEFT:\n        left_motor.spin(FORWARD, 50, PERCENT)\n        right_motor.spin(FORWARD, 50, PERCENT)\n    else:  # RIGHT turn\n        left_motor.spin(REVERSE, 50, PERCENT)\n        right_motor.spin(REVERSE, 50, PERCENT)\n    wait(turn_time_90, SECONDS)\n    left_motor.stop()\n    right_motor.stop()\n\ndef turn_45(direction=LEFT):\n    # Turn the robot 45 degrees\n    if direction == LEFT:\n        left_motor.spin(REVERSE, 45, PERCENT)\n        right_motor.spin(REVERSE, 45, PERCENT)\n    else:  # RIGHT turn\n        left_motor.spin(FORWARD, 45, PERCENT)\n        right_motor.spin(FORWARD, 45, PERCENT)\n    wait(turn_time_45, SECONDS)\n    left_motor.stop()\n    right_motor.stop()\n\ndef shimmy():\n    # Small left-right turns to search for the target\n    left_motor.spin_for(REVERSE, 90, DEGREES, 50, PERCENT, wait=False)\n    right_motor.spin_for(FORWARD, 90, DEGREES, 50, PERCENT, wait=True)\n    left_motor.spin_for(FORWARD, 90, DEGREES, 50, PERCENT, wait=False)\n    right_motor.spin_for(REVERSE, 90, DEGREES, 50, PERCENT, wait=True)\n\n# def search_and_approach_blue():\n#     while True:\n#         # Take a snapshot to detect the blue signature\n#         vision_17.take_snapshot(vision_17__BLUEBOX)\n        \n#         # Try to access the detected object's properties\n#         if vision_17.object_count > 0:\n#             # Object detected; move toward it\n#             move_one_rotation_f()\n#         else:\n#             # No object detected; perform shimmy motion\n#             shimmy()\n\n# Example autonomous sequence\ndef autonomous_routine():\n    # Initial movements and actions\n    open_claw()\n    move_one_rotation_b()\n    move_one_rotation_b()\n    # close_claw()\n   \n    # turn_90(RIGHT)\n    # turn_90(RIGHT)\n    \n    # move_one_rotation_f()\n    # move_one_rotation_f()\n\n    # turn_45(RIGHT)\n    # move_one_rotation_f()\n    # move_one_rotation_bh()\n    # move_one_rotation_fh()\n    # move_one_rotation_bh()\n    # move_one_rotation_fh()\n    # move_one_rotation_f()\n\n    # turn_45(RIGHT)\n    # move_one_rotation_f()\n    # move_one_rotation_bh()\n    # move_one_rotation_fh()\n    # move_one_rotation_bh()\n    # move_one_rotation_fh()\n    # move_one_rotation_f()\n\n    # turn_90(RIGHT)\n    # turn_90(RIGHT)\n    # turn_45(LEFT)\n    # move_one_rotation_b()\n    # turn_45(RIGHT)\n    # move_one_rotation_b()\n    # move_one_rotation_bh()\n\n    # open_claw()\n    # wait(2, MSEC)\n    # move_one_rotation_f()\n    # move_one_rotation_f()\n    \n    \n\n\n# Define stall detection parameters\nSTALL_SPEED_THRESHOLD = 5  # Adjust this value as needed\nSTALL_DETECTION_DELAY = 500  # Time in milliseconds to confirm a stall\n\n# Initialize stall timer\nstall_timer = 0\n\n# Controller-based loop for manual control\n\nwhile True:\n    #autonomous_routine()\n    # Driving Control\n    left_motor.spin(FORWARD, controller.axis3.position(), PERCENT)\n    right_motor.spin(REVERSE, controller.axis2.position(), PERCENT)\n\n    # Claw Control\n    if controller.buttonL1.pressing():\n        open_claw()\n    elif controller.buttonL2.pressing():\n        close_claw()\n\n    # Spin Control (R1 and R2)\n    if controller.buttonR1.pressing():\n        motor_a.spin(FORWARD, 100, PERCENT)\n        motor_b.spin(REVERSE, 100, PERCENT)\n        motor_c.spin(FORWARD, 100, PERCENT)\n        if abs(motor_c.velocity(PERCENT)) < STALL_SPEED_THRESHOLD:\n            stall_timer += 20\n            if stall_timer >= STALL_DETECTION_DELAY:\n                brain.screen.clear_screen()\n                brain.screen.print(\"Warning: Motor C Stalled!\")\n        else:\n            stall_timer = 0\n    elif controller.buttonR2.pressing():\n        motor_a.spin(REVERSE, 100, PERCENT)\n        motor_b.spin(FORWARD, 100, PERCENT)\n        motor_c.spin(REVERSE, 100, PERCENT)\n        stall_timer = 0\n    else:\n        motor_a.stop()\n        motor_b.stop()\n        motor_c.stop()\n        stall_timer = 0\n\n    # Lift Control\n    if controller.buttonA.pressing():\n        lift_l.spin(REVERSE, 20, PERCENT)\n        lift_r.spin(FORWARD, 20, PERCENT)\n    elif controller.buttonB.pressing():\n        lift_l.spin(FORWARD, 20, PERCENT)\n        lift_r.spin(REVERSE, 20, PERCENT)\n    else:\n        lift_l.stop()\n        lift_r.stop()\n\n    wait(20, MSEC)\n","textLanguage":"python","robotConfig":[{"port":[1],"name":"potentiometerV2_a","customName":false,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{},"triportSourcePort":22},{"port":[2],"name":"potentiometerV2_b","customName":false,"deviceType":"PotentiometerV2","deviceClass":"potV2","setting":{},"triportSourcePort":22},{"port":[11],"name":"ai_vision_11","customName":false,"deviceType":"AIVision","deviceClass":"aivision","setting":{"config":"{\"colors\":[{\"id\":2,\"name\":\"RED\",\"nameValid\":\"Valid\",\"lastValidName\":\"RED\",\"red\":208.35347222222222,\"green\":55.67951388888889,\"blue\":93.30451388888889,\"hueRange\":10,\"saturationRange\":0.2},{\"id\":1,\"name\":\"BLUE\",\"nameValid\":\"Valid\",\"lastValidName\":\"BLUE\",\"red\":66.74946120689656,\"green\":156.47144396551724,\"blue\":216.33584770114942,\"hueRange\":10,\"saturationRange\":0.2}],\"codes\":[],\"tags\":false,\"AIObjects\":false,\"AIObjectModel\":[\"Ball(Blue)\",\"Ball(Green)\",\"Ball(Red)\",\"Ring(Blue)\",\"Ring(Green)\",\"Ring(Red)\",\"Cube(Blue)\",\"Cube(Green)\",\"Cube(Red)\"],\"AIModelMetadata\":{\"id\":16,\"version\":1,\"name\":\"2024-2025 High Stakes\"},\"aiModelDropDownValue\":\"2024-2025 High Stakes\"}","isConfigured":"false"},"triportSourcePort":22}],"slot":7,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}